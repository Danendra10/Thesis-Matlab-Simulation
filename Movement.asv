% Simulation parameters
TOTAL_ = 200;
Kattr = 1;
Krepl = 1000;
d0 = 100; % Threshold distance for the repulsive potential
goal = [TOTAL_ * 0.5; TOTAL_ * 0.5]; % Initialize goal
obstacles = [50, 50; 100, 150; 150, 100; 80, 180; 180, 80]; % Obstacle coordinates
robotPos = [10; 10]; % Initial position of the robot
stepSize = 1; % The step size of the robot
maxIterations = 1000; % Maximum number of iterations to simulate
goalThreshold = 5; % Distance threshold to consider goal reached

% Initialize positions to calculate
[x, y] = meshgrid(linspace(0, TOTAL_, TOTAL_), linspace(0, TOTAL_, TOTAL_));

% Calculate attractive and repulsive potentials for each point in the grid
Uattr = zeros(size(x));
Urep = zeros(size(x));
Utotal = zeros(size(x));

for i = 1:size(x, 1)
    for j = 1:size(x, 2)
        pos = [x(i, j); y(i, j)];
        Uattr(i, j) = AttractiveField(pos, goal', Kattr);

        Urep(i, j) = 0;
        
        % Sum repulsive potentials from all obstacles
        for k = 1:size(obstacles, 1)
            obstacle = obstacles(k, :)';
            d = norm(pos - obstacle);
%             disp(d)
            Urep(i, j) = Urep(i, j) + RepulsiveField(d, d0, Krepl) ;
        end
        Utotal(i, j) = Uattr(i, j) + Urep(i, j);
    end
end

% Simulate robot movement
for iter = 1:maxIterations
    % Calculate gradient of the total potential at robot position
    [gradX, gradY] = gradient(Utotal);
    if abs(gradX(round(robotPos(2)), round(robotPos(1)))) > 20
        gradX(round(robotPos(2)), round(robotPos(1))) = 20 * gradX(round(robotPos(2)), round(robotPos(1))) / abs(gradX(round(robotPos(2)), round(robotPos(1))));
    end
    if abs(gradY(round(robotPos(2)), round(robotPos(1)))) > 20
        gradY(round(robotPos(2)), round(robotPos(1))) = 20 * gradY(round(robotPos(2)), round(robotPos(1))) / abs(gradY(round(robotPos(2)), round(robotPos(1))));
    end
%     disp("Grad X and Y")
%     disp(gradX(round(robotPos(2)), round(robotPos(1))))
%     disp(gradY(round(robotPos(2)), round(robotPos(1))))
    grad = [gradX(round(robotPos(2)), round(robotPos(1))); gradY(round(robotPos(2)), round(robotPos(1)))];
    
    % Move robot against the gradient
    robotPos = robotPos - stepSize * grad;
    
    % Keep the robot within bounds
    robotPos(1) = max(1, min(TOTAL_, robotPos(1)));
    robotPos(2) = max(1, min(TOTAL_, robotPos(2)));

%     disp(robotPos)
    
    % Check if the goal is reached
    if norm(robotPos - goal) < goalThreshold
        disp('Goal reached.');
        break;
    end
end

% Plotting the results
% Display the attractive potential field
figure
surf(x, y, Uattr)
title('Attractive Potential Field')
xlabel('x')
ylabel('y')
zlabel('U_{attr}')
shading interp
colorbar

% Display the repulsive potential field
figure
surf(x, y, Urep)
title('Repulsive Potential Field')
xlabel('x')
ylabel('y')
zlabel('U_{rep}')
shading interp
colorbar

% Display the total potential field
figure
surf(x, y, Utotal)
title('Total Potential Field')
xlabel('x')
ylabel('y')
zlabel('U_{total}')
shading interp
colorbar
hold on

% Plot the path of the robot as a line on the total potential field
plot3(robotPos(1), robotPos(2), Utotal(round(robotPos(2)), round(robotPos(1))), 'bo', 'MarkerSize', 10, 'MarkerFaceColor', 'blue');

% Label the robot's final position
text(robotPos(1), robotPos(2), Utotal(round(robotPos(2)), round(robotPos(1))), ' Robot', 'VerticalAlignment', 'bottom', 'HorizontalAlignment', 'right');

% Plot the goal position
plot3(goal(1), goal(2), Utotal(round(goal(2)), round(goal(1))), 'ro', 'MarkerSize', 10, 'MarkerFaceColor', 'red');
text(goal(1), goal(2), Utotal(round(goal(2)), round(goal(1))), ' Goal', 'VerticalAlignment', 'bottom', 'HorizontalAlignment', 'right');

% Plot obstacles
for k = 1:size(obstacles, 1)
    ob_pos = obstacles(k, :);
    plot3(ob_pos(1), ob_pos(2), Utotal(ob_pos(2),ob_pos(1)), 'ks', 'MarkerSize', 10, 'MarkerFaceColor', 'black');
    text(ob_pos(1), ob_pos(2), Utotal(ob_pos(2), ob_pos(1)), ' Obstacle', 'VerticalAlignment', 'bottom', 'HorizontalAlignment', 'right');
end

hold off % Release the figure

% Local and Global Minima and Maxima are not used for robot movement
% but you can calculate and display them if needed for analysis.
